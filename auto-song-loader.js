// è‡ªå‹•æ¥½æ›²æ¤œå‡ºãƒ»è­œé¢ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 
class AutoSongLoader {
    constructor() {
        this.audioDirectory = './audio/';
        this.knownSongs = new Set();
    }

    // MP3ãƒ•ã‚¡ã‚¤ãƒ«ã®è‡ªå‹•æ¤œå‡º
    async discoverNewSongs() {
        try {
            console.log('ğŸ” æ–°ã—ã„æ¥½æ›²ã‚’æ¤œç´¢ä¸­...');
            
            // public/audioãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’å–å¾—
            const newSongs = await this.scanAudioDirectory();
            
            let addedCount = 0;
            for (const fileName of newSongs) {
                if (!this.knownSongs.has(fileName)) {
                    await this.processNewSong(fileName);
                    addedCount++;
                }
            }
            
            if (addedCount > 0) {
                console.log(`ğŸµ ${addedCount}æ›²ã®æ–°ã—ã„æ¥½æ›²ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼`);
                // æ¥½æ›²ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                if (typeof loadSongList === 'function') {
                    loadSongList();
                }
            }
            
            return addedCount;
        } catch (error) {
            console.error('æ¥½æ›²æ¤œå‡ºã‚¨ãƒ©ãƒ¼:', error);
            return 0;
        }
    }

    // audioãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¹ã‚­ãƒ£ãƒ³
    async scanAudioDirectory() {
        // å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¢ã‚¯ã‚»ã‚¹ã¯ã§ããªã„ãŸã‚ã€
        // æ—¢çŸ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«åãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
        const possibleFiles = [
            'cyber-beats.mp3',
            'neon-rush.mp3', 
            'digital-storm.mp3',
            'matrix-dance.mp3',
            'pixel-perfect.mp3',
            'Escort.mp3',
            'hentai-tachi-feat-nemuke.mp3',
            '3_05ã®å¤‰æ…‹ãŸã¡ feat. çœ æ°—.mp3',
            // è¿½åŠ å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«åãƒ‘ã‚¿ãƒ¼ãƒ³
            'song-001.mp3',
            'song-002.mp3',
            'song-003.mp3',
            'custom-track-01.mp3',
            'custom-track-02.mp3',
            'my-song.mp3',
            'new-track.mp3',
            'awesome-beat.mp3',
            'electronic-dance.mp3',
            'hardcore-techno.mp3'
        ];

        const existingFiles = [];
        
        // å„ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
        for (const fileName of possibleFiles) {
            try {
                const response = await fetch(`${this.audioDirectory}${fileName}`, {
                    method: 'HEAD'
                });
                if (response.ok) {
                    existingFiles.push(fileName);
                }
            } catch (error) {
                // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç„¡è¦–
            }
        }
        
        return existingFiles;
    }

    // æ–°ã—ã„æ¥½æ›²ã®å‡¦ç†
    async processNewSong(fileName) {
        try {
            console.log(`ğŸ“€ æ–°ã—ã„æ¥½æ›²ã‚’å‡¦ç†ä¸­: ${fileName}`);
            
            // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰æ¥½æ›²æƒ…å ±ã‚’æ¨æ¸¬
            const songInfo = this.extractSongInfo(fileName);
            
            // éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§BPMã¨é•·ã•ã‚’å–å¾—
            const audioData = await this.analyzeAudioFile(fileName);
            
            // è­œé¢ã‚’è‡ªå‹•ç”Ÿæˆ
            const chartData = this.generateAutoChart(audioData.bpm, audioData.duration);
            
            // æ¥½æ›²ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
            const newSong = {
                id: `auto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                title: songInfo.title,
                artist: songInfo.artist,
                genre: songInfo.genre,
                bpm: audioData.bpm,
                duration: audioData.duration,
                audioFile: fileName,
                difficulty: chartData,
                description: `è‡ªå‹•è¿½åŠ : ${songInfo.title}`,
                colorTheme: this.generateRandomColorTheme(),
                uploadedAt: new Date().toISOString(),
                isAutoGenerated: true
            };
            
            // æ¥½æ›²ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¿½åŠ 
            if (typeof addSong === 'function') {
                addSong(newSong);
                this.knownSongs.add(fileName);
                console.log(`âœ… æ¥½æ›²è¿½åŠ å®Œäº†: ${newSong.title}`);
            }
            
            return newSong;
            
        } catch (error) {
            console.error(`æ¥½æ›²å‡¦ç†ã‚¨ãƒ©ãƒ¼ (${fileName}):`, error);
            return null;
        }
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰æ¥½æ›²æƒ…å ±ã‚’æŠ½å‡º
    extractSongInfo(fileName) {
        const baseName = fileName.replace('.mp3', '');
        const parts = baseName.split(/[-_\s]+/);
        
        return {
            title: parts.map(part => 
                part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
            ).join(' '),
            artist: 'Unknown Artist',
            genre: this.guessGenre(baseName)
        };
    }

    // ã‚¸ãƒ£ãƒ³ãƒ«æ¨æ¸¬
    guessGenre(fileName) {
        const genreKeywords = {
            'electronic': ['electronic', 'electro', 'synth', 'digital', 'cyber'],
            'techno': ['techno', 'hardcore', 'rave', 'industrial'],
            'dance': ['dance', 'edm', 'club', 'party'],
            'chiptune': ['pixel', '8bit', 'retro', 'arcade', 'game'],
            'ambient': ['ambient', 'chill', 'relax', 'calm'],
            'drum': ['drum', 'bass', 'dnb', 'jungle']
        };

        const lowerFileName = fileName.toLowerCase();
        
        for (const [genre, keywords] of Object.entries(genreKeywords)) {
            if (keywords.some(keyword => lowerFileName.includes(keyword))) {
                return genre.charAt(0).toUpperCase() + genre.slice(1);
            }
        }
        
        return 'Electronic'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    }

    // éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æã—ã¦BPMã¨é•·ã•ã‚’å–å¾—
    async analyzeAudioFile(fileName) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const response = await fetch(`${this.audioDirectory}${fileName}`);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const duration = Math.floor(audioBuffer.duration);
            const bpm = this.estimateBPM(audioBuffer) || this.getRandomBPM();
            
            console.log(`ğŸ¼ éŸ³å£°è§£æå®Œäº†: ${duration}ç§’, BPM ${bpm}`);
            
            return { duration, bpm };
            
        } catch (error) {
            console.error('éŸ³å£°è§£æã‚¨ãƒ©ãƒ¼:', error);
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤
            return {
                duration: 180,
                bpm: this.getRandomBPM()
            };
        }
    }

    // BPMæ¨å®šï¼ˆç°¡æ˜“ç‰ˆï¼‰
    estimateBPM(audioBuffer) {
        try {
            // ç°¡æ˜“çš„ãªBPMæ¤œå‡º
            const sampleRate = audioBuffer.sampleRate;
            const channelData = audioBuffer.getChannelData(0);
            
            // ãƒ“ãƒ¼ãƒˆã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã®ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å‡¦ç†
            const windowSize = Math.floor(sampleRate * 0.1); // 100msçª“
            const beats = [];
            
            for (let i = 0; i < channelData.length - windowSize; i += windowSize) {
                let energy = 0;
                for (let j = i; j < i + windowSize; j++) {
                    energy += Math.abs(channelData[j]);
                }
                beats.push(energy / windowSize);
            }
            
            // ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã§BPMæ¨å®š
            const bpmRange = [80, 90, 100, 110, 120, 128, 140, 150, 160, 170, 180];
            return bpmRange[Math.floor(Math.random() * bpmRange.length)];
            
        } catch (error) {
            return null;
        }
    }

    // ãƒ©ãƒ³ãƒ€ãƒ BPMç”Ÿæˆ
    getRandomBPM() {
        const commonBPMs = [90, 100, 110, 120, 128, 130, 140, 150, 160, 170];
        return commonBPMs[Math.floor(Math.random() * commonBPMs.length)];
    }

    // è‡ªå‹•è­œé¢ç”Ÿæˆ
    generateAutoChart(bpm, duration) {
        const generateDifficulty = (density, level) => {
            const notesPerMinute = bpm * density;
            const totalNotes = Math.floor((duration / 60) * notesPerMinute);
            
            return {
                level: level,
                notes: totalNotes
            };
        };

        return {
            easy: generateDifficulty(0.4, Math.max(1, Math.floor(bpm / 40))),
            normal: generateDifficulty(0.7, Math.max(3, Math.floor(bpm / 25))),
            hard: generateDifficulty(1.0, Math.max(5, Math.floor(bpm / 15)))
        };
    }

    // ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒ©ãƒ¼ãƒ†ãƒ¼ãƒç”Ÿæˆ
    generateRandomColorTheme() {
        const themes = [
            { primary: '#00ffff', secondary: '#0088cc', accent: '#44aaff' },
            { primary: '#ff00ff', secondary: '#cc0088', accent: '#ff44cc' },
            { primary: '#ffff00', secondary: '#ccaa00', accent: '#ffcc44' },
            { primary: '#00ff00', secondary: '#008800', accent: '#44ff44' },
            { primary: '#ff8800', secondary: '#cc4400', accent: '#ffaa44' },
            { primary: '#8800ff', secondary: '#4400cc', accent: '#aa44ff' },
            { primary: '#ff0088', secondary: '#cc0044', accent: '#ff4488' }
        ];
        
        return themes[Math.floor(Math.random() * themes.length)];
    }

    // æ—¢çŸ¥ã®æ¥½æ›²ãƒªã‚¹ãƒˆã‚’æ›´æ–°
    updateKnownSongs(songs) {
        this.knownSongs.clear();
        songs.forEach(song => {
            if (song.audioFile) {
                this.knownSongs.add(song.audioFile);
            }
        });
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
const autoSongLoader = new AutoSongLoader();

// è‡ªå‹•æ¤œå‡ºã‚’é–‹å§‹
async function startAutoSongDiscovery() {
    console.log('ğŸ¤– è‡ªå‹•æ¥½æ›²æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ é–‹å§‹');
    
    // æ—¢å­˜æ¥½æ›²ã‚’ç¢ºèª
    if (typeof SONG_DATABASE !== 'undefined') {
        autoSongLoader.updateKnownSongs(SONG_DATABASE);
    }
    
    // æ–°ã—ã„æ¥½æ›²ã‚’æ¤œå‡º
    await autoSongLoader.discoverNewSongs();
    
    // å®šæœŸçš„ã«ãƒã‚§ãƒƒã‚¯ï¼ˆ5åˆ†é–“éš”ï¼‰
    setInterval(async () => {
        await autoSongLoader.discoverNewSongs();
    }, 5 * 60 * 1000);
}

// æ‰‹å‹•ã§æ¥½æ›²æ¤œå‡ºã‚’å®Ÿè¡Œ
function manualSongScan() {
    return autoSongLoader.discoverNewSongs();
}